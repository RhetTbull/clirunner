{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CliRunner","text":"<p>A test helper for invoking and testing command line interfaces (CLIs). This is adapted from the Click CliRunner but modified to work with non-Click scripts, such as those using argparse for parsing command line arguments.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>python3 -m pip install clirunner</code></p>"},{"location":"#source-code","title":"Source Code","text":"<p>The source code is available on GitHub.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>I write a lot of Python command line tools. I usually reach for Click to build the CLI but sometimes will use argparse or even just manual <code>sys.argv</code> parsing for simple scripts or where I do not want to introduce a dependency on Click. Click provides a very useful CliRunner for testing CLIs, but it only works with Click applications. This project is a derivative of Click's CliRunner that works with non-Click scripts. The API is the same as Click's CliRunner, so it should be easy to switch between the two if you later refactor to use Click.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>Tested on macOS, Ubuntu Linux, and Windows using \"*-latest\" GitHub Workflow runners with Python 3.9 - 3.12.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation is available here.</p>"},{"location":"#basic-testing","title":"Basic Testing","text":"<p>CliRunner can invoke your CLI's main function as a command line script. The CliRunner.invoke() method runs the command line script in isolation and captures the output as both bytes and binary data.</p> <p>The return value is a Result object, which has the captured output data, exit code, and optional exception attached:</p>"},{"location":"#hellopy","title":"hello.py","text":"<pre><code>\"\"\"Simple CLI \"\"\"\n\nimport argparse\n\n\ndef hello():\n    \"\"\"Print Hello World\"\"\"\n    argp = argparse.ArgumentParser(description=\"Print Hello World\")\n    argp.add_argument(\"-n\", \"--name\", help=\"Name to greet\")\n    args = argp.parse_args()\n    print(f\"Hello {args.name or 'World'}!\")\n\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre>"},{"location":"#test_hellopy","title":"test_hello.py","text":"<pre><code>\"\"\"Test hello.py\"\"\"\n\nfrom hello import hello\n\nfrom clirunner import CliRunner\n\n\ndef test_hello_world():\n    runner = CliRunner()\n    result = runner.invoke(hello, [\"--name\", \"Peter\"])\n    assert result.exit_code == 0\n    assert result.output == \"Hello Peter!\\n\"\n</code></pre> <p>Note that <code>result.output</code> will contain the combined output of <code>stdout</code> and <code>stderr</code>. If you want to capture <code>stdout</code> and <code>stderr</code> separately, use <code>result.stdout</code> and <code>result.stderr</code>.</p>"},{"location":"#file-system-isolation","title":"File System Isolation","text":"<p>For basic command line tools with file system operations, the <code>CliRunner.isolated_filesystem()</code> method is useful for setting the current working directory to a new, empty folder.</p>"},{"location":"#catpy","title":"cat.py","text":"<pre><code>\"\"\"Simple cat program for testing isolated file system\"\"\"\n\nimport argparse\n\n\ndef cat():\n    argp = argparse.ArgumentParser()\n    argp.add_argument(\"file\", type=argparse.FileType(\"r\"))\n    args = argp.parse_args()\n    print(args.file.read(), end=\"\")\n\n\nif __name__ == \"__main__\":\n    cat()\n</code></pre>"},{"location":"#test_catpy","title":"test_cat.py","text":"<pre><code>\"\"\"Test cat.py example.\"\"\"\n\nfrom cat import cat\n\nfrom clirunner import CliRunner\n\n\ndef test_cat():\n    runner = CliRunner()\n    with runner.isolated_filesystem():\n        with open(\"hello.txt\", \"w\") as f:\n            f.write(\"Hello World!\\n\")\n\n        result = runner.invoke(cat, [\"hello.txt\"])\n        assert result.exit_code == 0\n        assert result.output == \"Hello World!\\n\"\n</code></pre> <p>Pass <code>temp_dir</code> to control where the temporary directory is created. The directory will not be removed by <code>CliRunner</code> in this case. This is useful to integrate with a framework like Pytest that manages temporary files.</p> <pre><code>def test_keep_dir(tmp_path):\n    runner = CliRunner()\n\n    with runner.isolated_filesystem(temp_dir=tmp_path) as td:\n        ...\n</code></pre>"},{"location":"#input-streams","title":"Input Streams","text":"<p>The test wrapper can also be used to provide input data for the input stream (stdin). This is very useful for testing prompts, for instance:</p>"},{"location":"#promptpy","title":"prompt.py","text":"<pre><code>\"\"\"Simple example for testing input streams\"\"\"\n\n\ndef prompt():\n    foo = input(\"Foo: \")\n    print(f\"foo = {foo}\")\n\n\nif __name__ == \"__main__\":\n    prompt()\n</code></pre>"},{"location":"#test_promptpy","title":"test_prompt.py","text":"<pre><code>\"\"\"Test prompt.py example\"\"\"\n\nfrom prompt import prompt\n\nfrom clirunner import CliRunner\n\n\ndef test_prompts():\n    runner = CliRunner()\n    result = runner.invoke(prompt, input=\"wau wau\\n\")\n    assert not result.exception\n    # note: unlike click.CliRunner, clirunner.CliRunner does not echo the input\n    assert \"foo = wau wau\\n\" in result.output\n</code></pre> <p>Note that the input will not be echoed to the output stream. This is different from the behavior of the <code>input()</code> function, which does echo the input and from click's <code>prompt()</code> function, which also echo's the input when under test.</p>"},{"location":"#environment-variable-isolation","title":"Environment Variable Isolation","text":"<p>The <code>CliRunner.invoke()</code> method can also be used to set environment variables for the command line script. This is useful for testing command line tools that use environment variables for configuration.</p>"},{"location":"#hello_envpy","title":"hello_env.py","text":"<pre><code>\"\"\"Say hello to the world, shouting if desired.\"\"\"\n\nimport os\n\n\ndef hello():\n    \"\"\"Say hello to the world, shouting if desired.\"\"\"\n    if os.getenv(\"SHOUT\") == \"1\":\n        print(\"HELLO WORLD!\")\n    else:\n        print(\"Hello World!\")\n\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre>"},{"location":"#test_hello_envpy","title":"test_hello_env.py","text":"<pre><code>\"\"\"Test hello2.py showing how to set environment variables for testing.\"\"\"\n\nfrom hello_env import hello\n\nfrom clirunner import CliRunner\n\n\ndef test_hello():\n    \"\"\"Test hello2.py\"\"\"\n    runner = CliRunner()\n    result = runner.invoke(hello)\n    assert result.exit_code == 0\n    assert result.output == \"Hello World!\\n\"\n\n\ndef test_hello_shouting():\n    \"\"\"Test hello2.py\"\"\"\n    runner = CliRunner()\n    result = runner.invoke(hello, env={\"SHOUT\": \"1\"})\n    assert result.exit_code == 0\n    assert result.output == \"HELLO WORLD!\\n\"\n</code></pre>"},{"location":"#handling-exceptions","title":"Handling Exceptions","text":"<p>Normally the <code>CliRunner.invoke()</code> method will catch exceptions in the CLI under test. If an exception is raised, it will be available via the <code>Result.exception</code> property. This can be disabled by passing <code>catch_exceptions=False</code> to the <code>CliRunner.invoke()</code> method.</p>"},{"location":"#raise_exceptionpy","title":"raise_exception.py","text":"<pre><code>\"\"\"Simple script that raises an exception\"\"\"\n\n\ndef raise_exception():\n    \"\"\"Raises a ValueError exception\"\"\"\n    raise ValueError(\"Exception raised\")\n\n\nif __name__ == \"__main__\":\n    raise_exception()\n</code></pre>"},{"location":"#test_raise_exceptionpy","title":"test_raise_exception.py","text":"<pre><code>\"\"\"Test raise_exception.py\"\"\"\n\nimport pytest\nfrom raise_exception import raise_exception\n\nfrom clirunner import CliRunner\n\n\ndef test_exception_caught():\n    \"\"\"CliRunner normally catches exceptions\"\"\"\n    runner = CliRunner()\n    result = runner.invoke(raise_exception)\n    # exit code will not be 0 if exception is raised\n    assert result.exit_code != 0\n    assert isinstance(result.exception, ValueError)\n\n\ndef test_exception_not_caught():\n    \"\"\"CliRunner can be configured to not catch exceptions\"\"\"\n    runner = CliRunner()\n    with pytest.raises(ValueError):\n        runner.invoke(raise_exception, catch_exceptions=False)\n</code></pre>"},{"location":"#testing-click-applications","title":"Testing Click Applications","text":"<p>Do not use <code>clirunner.CliRunner</code> to test applications built with Click, Typer, or another Click derivative. Instead, use Click's built-in CliRunner or Typer's equivalent.</p> <p><code>clirunner.CliRunner</code> is designed for testing non-Click scripts such as those using argparse or manual sys.argv argument parsing. It has also been tested with pydantic-argparse, clipstick, and tyro.</p>"},{"location":"#license","title":"License","text":"<p>CliRunner is a derivative work of Click's CliRunner, and so it is licensed under the same BSD 3-clause license as Click. See the LICENSE and LICENSE.Click files for details.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#clirunner","title":"CliRunner","text":"<p>The CLI runner provides functionality to invoke a command line script for unit testing purposes in a isolated environment.  This only works in single-threaded systems without any concurrency as it changes the global interpreter state.</p> <p>Parameters:</p> Name Type Description Default <code>charset</code> <code>str</code> <p>the character set for the input and output data.</p> <code>'utf-8'</code> <code>env</code> <code>Mapping[str, str | None] | None</code> <p>a dictionary with environment variables for overriding.</p> <code>None</code> <code>echo_stdin</code> <code>bool</code> <p>if this is set to <code>True</code>, then reading from <code>&lt;stdin&gt;</code> writes to <code>&lt;stdout&gt;</code>.  This is useful for showing examples in some circumstances.</p> <code>False</code> Source code in <code>clirunner/testing.py</code> <pre><code>class CliRunner:\n    \"\"\"The CLI runner provides functionality to invoke a command line\n    script for unit testing purposes in a isolated environment.  This only\n    works in single-threaded systems without any concurrency as it changes the\n    global interpreter state.\n\n    Args:\n        charset: the character set for the input and output data.\n        env: a dictionary with environment variables for overriding.\n        echo_stdin: if this is set to `True`, then reading from `&lt;stdin&gt;` writes\n            to `&lt;stdout&gt;`.  This is useful for showing examples in\n            some circumstances.\n    \"\"\"\n\n    def __init__(\n        self,\n        charset: str = \"utf-8\",\n        env: cabc.Mapping[str, str | None] | None = None,\n        echo_stdin: bool = False,\n    ) -&gt; None:\n        self.charset = charset\n        self.env: cabc.Mapping[str, str | None] = env or {}\n        self.echo_stdin = echo_stdin\n\n    def get_default_prog_name(self, cli: t.Callable[..., t.Any]) -&gt; str:\n        \"\"\"Given a callable return the default program name for it.\"\"\"\n        try:\n            return cli.__name__ or \"main\"\n        except AttributeError:\n            # if used with a CLI framework that creates objects like Click\n            # there is no __name__ attribute\n            return \"main\"\n\n    def make_env(\n        self, overrides: cabc.Mapping[str, str | None] | None = None\n    ) -&gt; cabc.Mapping[str, str | None]:\n        \"\"\"Returns the environment overrides for invoking a script.\"\"\"\n        rv = dict(self.env)\n        if overrides:\n            rv.update(overrides)\n        return rv\n\n    @contextlib.contextmanager\n    def isolation(\n        self,\n        input: str | bytes | t.IO[t.Any] | None = None,\n        env: cabc.Mapping[str, str | None] | None = None,\n        # color: bool = False,\n    ) -&gt; cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]:\n        \"\"\"A context manager that sets up the isolation for invoking of a\n        command line tool.  This sets up `&lt;stdin&gt;` with the given input data\n        and `os.environ` with the overrides from the given dictionary.\n\n        This is automatically done in the `invoke` method.\n\n        Args:\n            input: the input stream to put into `sys.stdin`.\n            env: the environment overrides as dictionary.\n        \"\"\"\n        # TODO: I don't think we need this color parameter as that is Click specific\n\n        bytes_input = make_input_stream(input, self.charset)\n        echo_input = None\n\n        old_stdin = sys.stdin\n        old_stdout = sys.stdout\n        old_stderr = sys.stderr\n\n        env = self.make_env(env)\n\n        stream_mixer = StreamMixer()\n\n        if self.echo_stdin:\n            bytes_input = echo_input = t.cast(\n                t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n            )\n\n        sys.stdin = text_input = _NamedTextIOWrapper(\n            bytes_input, encoding=self.charset, name=\"&lt;stdin&gt;\", mode=\"r\"\n        )\n\n        if self.echo_stdin:\n            # Force unbuffered reads, otherwise TextIOWrapper reads a\n            # large chunk which is echoed early.\n            text_input._CHUNK_SIZE = 1  # type: ignore\n\n        sys.stdout = _NamedTextIOWrapper(\n            stream_mixer.stdout, encoding=self.charset, name=\"&lt;stdout&gt;\", mode=\"w\"\n        )\n\n        sys.stderr = _NamedTextIOWrapper(\n            stream_mixer.stderr,\n            encoding=self.charset,\n            name=\"&lt;stderr&gt;\",\n            mode=\"w\",\n            errors=\"backslashreplace\",\n        )\n\n        # default_color = color\n\n        # def should_strip_ansi(\n        #     stream: t.IO[t.Any] | None = None, color: bool | None = None\n        # ) -&gt; bool:\n        #     if color is None:\n        #         return not default_color\n        #     return not color\n\n        # old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n        # utils.should_strip_ansi = should_strip_ansi  # type: ignore\n\n        old_env = {}\n        try:\n            for key, value in env.items():\n                old_env[key] = os.environ.get(key)\n                if value is None:\n                    try:\n                        del os.environ[key]\n                    except Exception:\n                        pass\n                else:\n                    os.environ[key] = value\n            yield (stream_mixer.stdout, stream_mixer.stderr, stream_mixer.output)\n        finally:\n            for key, value in old_env.items():\n                if value is None:\n                    try:\n                        del os.environ[key]\n                    except Exception:\n                        pass\n                else:\n                    os.environ[key] = value\n            sys.stdout = old_stdout\n            sys.stderr = old_stderr\n            sys.stdin = old_stdin\n            # utils.should_strip_ansi = old_should_strip_ansi  # type: ignore\n\n    def invoke(\n        self,\n        cli: t.Callable[..., t.Any],\n        args: str | cabc.Sequence[str] | None = None,\n        input: str | bytes | t.IO[t.Any] | None = None,\n        env: cabc.Mapping[str, str | None] | None = None,\n        catch_exceptions: bool = True,\n        # color: bool = False,\n        **extra: t.Any,\n    ) -&gt; Result:\n        \"\"\"Invokes a command in an isolated environment.  The arguments are\n        forwarded directly to the command line script.\n\n        Args:\n            cli: the command to invoke\n            args: the arguments to invoke. It may be given as an iterable\n                or a string. When given as string it will be interpreted\n                as a Unix shell command. More details at\n                `shlex.split`.\n            input: the input data for `sys.stdin`.\n            env: the environment overrides.\n            catch_exceptions: Whether to catch any other exceptions than\n                ``SystemExit``.\n\n        Returns: `Result` object with results of the invocation.\n        \"\"\"\n        exc_info = None\n        with self.isolation(input=input, env=env) as outstreams:\n            return_value = None\n            exception: BaseException | None = None\n            exit_code = 0\n\n            if isinstance(args, str):\n                args = shlex.split(args)\n\n            try:\n                prog_name = extra.pop(\"prog_name\")\n            except KeyError:\n                prog_name = self.get_default_prog_name(cli)\n\n            # set up sys.argv properly with the arguments\n            call_args = args or []\n            old_argv = sys.argv\n            sys.argv = [prog_name, *call_args]\n            try:\n                return_value = cli()\n                # If the command returns an integer, treat it as an exit code\n                if isinstance(return_value, int) and return_value != 0:\n                    raise SystemExit(return_value)\n            except SystemExit as e:\n                exc_info = sys.exc_info()\n                e_code = t.cast(\"int | t.Any | None\", e.code)\n\n                if e_code is None:\n                    e_code = 0\n\n                if e_code != 0:\n                    exception = e\n\n                if not isinstance(e_code, int):\n                    sys.stdout.write(str(e_code))\n                    sys.stdout.write(\"\\n\")\n                    e_code = 1\n\n                exit_code = e_code\n\n            except Exception as e:\n                if not catch_exceptions:\n                    raise\n                exception = e\n                exit_code = 1\n                exc_info = sys.exc_info()\n            finally:\n                sys.argv = old_argv\n                sys.stdout.flush()\n                sys.stderr.flush()\n                stdout = outstreams[0].getvalue()\n                stderr = outstreams[1].getvalue()\n                output = outstreams[2].getvalue()\n\n        return Result(\n            runner=self,\n            stdout_bytes=stdout,\n            stderr_bytes=stderr,\n            output_bytes=output,\n            return_value=return_value,\n            exit_code=exit_code,\n            exception=exception,\n            exc_info=exc_info,  # type: ignore\n        )\n\n    @contextlib.contextmanager\n    def isolated_filesystem(\n        self, temp_dir: str | os.PathLike[str] | None = None\n    ) -&gt; cabc.Iterator[str]:\n        \"\"\"A context manager that creates a temporary directory and\n        changes the current working directory to it. This isolates tests\n        that affect the contents of the CWD to prevent them from\n        interfering with each other.\n\n        Args:\n            temp_dir: Create the temporary directory under this\n                directory. If given, the created directory is not removed\n                when exiting.\n        \"\"\"\n        cwd = os.getcwd()\n        dt = tempfile.mkdtemp(dir=temp_dir)\n        os.chdir(dt)\n\n        try:\n            yield dt\n        finally:\n            os.chdir(cwd)\n\n            if temp_dir is None:\n                try:\n                    shutil.rmtree(dt)\n                except OSError:  # noqa: B014\n                    pass\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.get_default_prog_name","title":"<code>get_default_prog_name(cli)</code>","text":"<p>Given a callable return the default program name for it.</p> Source code in <code>clirunner/testing.py</code> <pre><code>def get_default_prog_name(self, cli: t.Callable[..., t.Any]) -&gt; str:\n    \"\"\"Given a callable return the default program name for it.\"\"\"\n    try:\n        return cli.__name__ or \"main\"\n    except AttributeError:\n        # if used with a CLI framework that creates objects like Click\n        # there is no __name__ attribute\n        return \"main\"\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.invoke","title":"<code>invoke(cli, args=None, input=None, env=None, catch_exceptions=True, **extra)</code>","text":"<p>Invokes a command in an isolated environment.  The arguments are forwarded directly to the command line script.</p> <p>Parameters:</p> Name Type Description Default <code>cli</code> <code>Callable[..., Any]</code> <p>the command to invoke</p> required <code>args</code> <code>str | Sequence[str] | None</code> <p>the arguments to invoke. It may be given as an iterable or a string. When given as string it will be interpreted as a Unix shell command. More details at <code>shlex.split</code>.</p> <code>None</code> <code>input</code> <code>str | bytes | IO[Any] | None</code> <p>the input data for <code>sys.stdin</code>.</p> <code>None</code> <code>env</code> <code>Mapping[str, str | None] | None</code> <p>the environment overrides.</p> <code>None</code> <code>catch_exceptions</code> <code>bool</code> <p>Whether to catch any other exceptions than <code>SystemExit</code>.</p> <code>True</code> <p>Returns: <code>Result</code> object with results of the invocation.</p> Source code in <code>clirunner/testing.py</code> <pre><code>def invoke(\n    self,\n    cli: t.Callable[..., t.Any],\n    args: str | cabc.Sequence[str] | None = None,\n    input: str | bytes | t.IO[t.Any] | None = None,\n    env: cabc.Mapping[str, str | None] | None = None,\n    catch_exceptions: bool = True,\n    # color: bool = False,\n    **extra: t.Any,\n) -&gt; Result:\n    \"\"\"Invokes a command in an isolated environment.  The arguments are\n    forwarded directly to the command line script.\n\n    Args:\n        cli: the command to invoke\n        args: the arguments to invoke. It may be given as an iterable\n            or a string. When given as string it will be interpreted\n            as a Unix shell command. More details at\n            `shlex.split`.\n        input: the input data for `sys.stdin`.\n        env: the environment overrides.\n        catch_exceptions: Whether to catch any other exceptions than\n            ``SystemExit``.\n\n    Returns: `Result` object with results of the invocation.\n    \"\"\"\n    exc_info = None\n    with self.isolation(input=input, env=env) as outstreams:\n        return_value = None\n        exception: BaseException | None = None\n        exit_code = 0\n\n        if isinstance(args, str):\n            args = shlex.split(args)\n\n        try:\n            prog_name = extra.pop(\"prog_name\")\n        except KeyError:\n            prog_name = self.get_default_prog_name(cli)\n\n        # set up sys.argv properly with the arguments\n        call_args = args or []\n        old_argv = sys.argv\n        sys.argv = [prog_name, *call_args]\n        try:\n            return_value = cli()\n            # If the command returns an integer, treat it as an exit code\n            if isinstance(return_value, int) and return_value != 0:\n                raise SystemExit(return_value)\n        except SystemExit as e:\n            exc_info = sys.exc_info()\n            e_code = t.cast(\"int | t.Any | None\", e.code)\n\n            if e_code is None:\n                e_code = 0\n\n            if e_code != 0:\n                exception = e\n\n            if not isinstance(e_code, int):\n                sys.stdout.write(str(e_code))\n                sys.stdout.write(\"\\n\")\n                e_code = 1\n\n            exit_code = e_code\n\n        except Exception as e:\n            if not catch_exceptions:\n                raise\n            exception = e\n            exit_code = 1\n            exc_info = sys.exc_info()\n        finally:\n            sys.argv = old_argv\n            sys.stdout.flush()\n            sys.stderr.flush()\n            stdout = outstreams[0].getvalue()\n            stderr = outstreams[1].getvalue()\n            output = outstreams[2].getvalue()\n\n    return Result(\n        runner=self,\n        stdout_bytes=stdout,\n        stderr_bytes=stderr,\n        output_bytes=output,\n        return_value=return_value,\n        exit_code=exit_code,\n        exception=exception,\n        exc_info=exc_info,  # type: ignore\n    )\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.isolated_filesystem","title":"<code>isolated_filesystem(temp_dir=None)</code>","text":"<p>A context manager that creates a temporary directory and changes the current working directory to it. This isolates tests that affect the contents of the CWD to prevent them from interfering with each other.</p> <p>Parameters:</p> Name Type Description Default <code>temp_dir</code> <code>str | PathLike[str] | None</code> <p>Create the temporary directory under this directory. If given, the created directory is not removed when exiting.</p> <code>None</code> Source code in <code>clirunner/testing.py</code> <pre><code>@contextlib.contextmanager\ndef isolated_filesystem(\n    self, temp_dir: str | os.PathLike[str] | None = None\n) -&gt; cabc.Iterator[str]:\n    \"\"\"A context manager that creates a temporary directory and\n    changes the current working directory to it. This isolates tests\n    that affect the contents of the CWD to prevent them from\n    interfering with each other.\n\n    Args:\n        temp_dir: Create the temporary directory under this\n            directory. If given, the created directory is not removed\n            when exiting.\n    \"\"\"\n    cwd = os.getcwd()\n    dt = tempfile.mkdtemp(dir=temp_dir)\n    os.chdir(dt)\n\n    try:\n        yield dt\n    finally:\n        os.chdir(cwd)\n\n        if temp_dir is None:\n            try:\n                shutil.rmtree(dt)\n            except OSError:  # noqa: B014\n                pass\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.isolation","title":"<code>isolation(input=None, env=None)</code>","text":"<p>A context manager that sets up the isolation for invoking of a command line tool.  This sets up <code>&lt;stdin&gt;</code> with the given input data and <code>os.environ</code> with the overrides from the given dictionary.</p> <p>This is automatically done in the <code>invoke</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str | bytes | IO[Any] | None</code> <p>the input stream to put into <code>sys.stdin</code>.</p> <code>None</code> <code>env</code> <code>Mapping[str, str | None] | None</code> <p>the environment overrides as dictionary.</p> <code>None</code> Source code in <code>clirunner/testing.py</code> <pre><code>@contextlib.contextmanager\ndef isolation(\n    self,\n    input: str | bytes | t.IO[t.Any] | None = None,\n    env: cabc.Mapping[str, str | None] | None = None,\n    # color: bool = False,\n) -&gt; cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]:\n    \"\"\"A context manager that sets up the isolation for invoking of a\n    command line tool.  This sets up `&lt;stdin&gt;` with the given input data\n    and `os.environ` with the overrides from the given dictionary.\n\n    This is automatically done in the `invoke` method.\n\n    Args:\n        input: the input stream to put into `sys.stdin`.\n        env: the environment overrides as dictionary.\n    \"\"\"\n    # TODO: I don't think we need this color parameter as that is Click specific\n\n    bytes_input = make_input_stream(input, self.charset)\n    echo_input = None\n\n    old_stdin = sys.stdin\n    old_stdout = sys.stdout\n    old_stderr = sys.stderr\n\n    env = self.make_env(env)\n\n    stream_mixer = StreamMixer()\n\n    if self.echo_stdin:\n        bytes_input = echo_input = t.cast(\n            t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n        )\n\n    sys.stdin = text_input = _NamedTextIOWrapper(\n        bytes_input, encoding=self.charset, name=\"&lt;stdin&gt;\", mode=\"r\"\n    )\n\n    if self.echo_stdin:\n        # Force unbuffered reads, otherwise TextIOWrapper reads a\n        # large chunk which is echoed early.\n        text_input._CHUNK_SIZE = 1  # type: ignore\n\n    sys.stdout = _NamedTextIOWrapper(\n        stream_mixer.stdout, encoding=self.charset, name=\"&lt;stdout&gt;\", mode=\"w\"\n    )\n\n    sys.stderr = _NamedTextIOWrapper(\n        stream_mixer.stderr,\n        encoding=self.charset,\n        name=\"&lt;stderr&gt;\",\n        mode=\"w\",\n        errors=\"backslashreplace\",\n    )\n\n    # default_color = color\n\n    # def should_strip_ansi(\n    #     stream: t.IO[t.Any] | None = None, color: bool | None = None\n    # ) -&gt; bool:\n    #     if color is None:\n    #         return not default_color\n    #     return not color\n\n    # old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n    # utils.should_strip_ansi = should_strip_ansi  # type: ignore\n\n    old_env = {}\n    try:\n        for key, value in env.items():\n            old_env[key] = os.environ.get(key)\n            if value is None:\n                try:\n                    del os.environ[key]\n                except Exception:\n                    pass\n            else:\n                os.environ[key] = value\n        yield (stream_mixer.stdout, stream_mixer.stderr, stream_mixer.output)\n    finally:\n        for key, value in old_env.items():\n            if value is None:\n                try:\n                    del os.environ[key]\n                except Exception:\n                    pass\n            else:\n                os.environ[key] = value\n        sys.stdout = old_stdout\n        sys.stderr = old_stderr\n        sys.stdin = old_stdin\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.make_env","title":"<code>make_env(overrides=None)</code>","text":"<p>Returns the environment overrides for invoking a script.</p> Source code in <code>clirunner/testing.py</code> <pre><code>def make_env(\n    self, overrides: cabc.Mapping[str, str | None] | None = None\n) -&gt; cabc.Mapping[str, str | None]:\n    \"\"\"Returns the environment overrides for invoking a script.\"\"\"\n    rv = dict(self.env)\n    if overrides:\n        rv.update(overrides)\n    return rv\n</code></pre>"}]}