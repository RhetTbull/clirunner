{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CliRunner","text":"<p>A test helper for invoking and testing command line interfaces (CLIs). This is adapted from the Click CliRunner but modified to work with non-Click scripts, such as those using argparse for parsing command line arguments.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>python3 -m pip install clirunner</code></p>"},{"location":"#source-code","title":"Source Code","text":"<p>The source code is available on GitHub.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>I write a lot of Python command line tools. I usually reach for Click to build the CLI but sometimes will use argparse or even just manual <code>sys.argv</code> parsing for simple scripts or where I do not want to introduce a dependency on Click. Click provides a very useful CliRunner for testing CLIs, but it only works with Click applications. This project is a derivative of Click's CliRunner that works with non-Click scripts. The API is the same as Click's CliRunner, so it should be easy to switch between the two if you later refactor to use Click.</p>"},{"location":"#basic-testing","title":"Basic Testing","text":"<p>CliRunner can invoke your CLI's main function as a command line script. The CliRunner.invoke() method runs the command line script in isolation and captures the output as both bytes and binary data.</p> <p>The return value is a Result object, which has the captured output data, exit code, and optional exception attached:</p>"},{"location":"#hellopy","title":"hello.py","text":"<pre><code>\"\"\"Simple CLI \"\"\"\n\nimport argparse\n\n\ndef hello():\n    \"\"\"Print Hello World\"\"\"\n    argp = argparse.ArgumentParser(description=\"Print Hello World\")\n    argp.add_argument(\"-n\", \"--name\", help=\"Name to greet\")\n    args = argp.parse_args()\n    print(f\"Hello {args.name or 'World'}!\")\n\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre>"},{"location":"#test_hellopy","title":"test_hello.py","text":"<pre><code>\"\"\"Test hello.py\"\"\"\n\nfrom hello import hello\n\nfrom clirunner import CliRunner\n\n\ndef test_hello_world():\n    runner = CliRunner()\n    result = runner.invoke(hello, [\"--name\", \"Peter\"])\n    assert result.exit_code == 0\n    assert result.output == \"Hello Peter!\\n\"\n</code></pre> <p>Note that <code>result.output</code> will contain the combined output of <code>stdout</code> and <code>stderr</code>. If you want to capture <code>stdout</code> and <code>stderr</code> separately, use <code>result.stdout</code> and <code>result.stderr</code>.</p>"},{"location":"#file-system-isolation","title":"File System Isolation","text":"<p>For basic command line tools with file system operations, the <code>CliRunner.isolated_filesystem()</code> method is useful for setting the current working directory to a new, empty folder.</p>"},{"location":"#catpy","title":"cat.py","text":"<pre><code>\"\"\"Simple cat program for testing isolated file system\"\"\"\n\nimport argparse\n\n\ndef cat():\n    argp = argparse.ArgumentParser()\n    argp.add_argument(\"file\", type=argparse.FileType(\"r\"))\n    args = argp.parse_args()\n    print(args.file.read(), end=\"\")\n\n\nif __name__ == \"__main__\":\n    cat()\n</code></pre>"},{"location":"#test_catpy","title":"test_cat.py","text":"<pre><code>\"\"\"Test cat.py example.\"\"\"\n\nfrom cat import cat\n\nfrom clirunner import CliRunner\n\n\ndef test_cat():\n    runner = CliRunner()\n    with runner.isolated_filesystem():\n        with open(\"hello.txt\", \"w\") as f:\n            f.write(\"Hello World!\\n\")\n\n        result = runner.invoke(cat, [\"hello.txt\"])\n        assert result.exit_code == 0\n        assert result.output == \"Hello World!\\n\"\n</code></pre> <p>Pass <code>temp_dir</code> to control where the temporary directory is created. The directory will not be removed by <code>CliRunner</code> in this case. This is useful to integrate with a framework like Pytest that manages temporary files.</p> <pre><code>def test_keep_dir(tmp_path):\n    runner = CliRunner()\n\n    with runner.isolated_filesystem(temp_dir=tmp_path) as td:\n        ...\n</code></pre>"},{"location":"#input-streams","title":"Input Streams","text":"<p>The test wrapper can also be used to provide input data for the input stream (stdin). This is very useful for testing prompts, for instance:</p>"},{"location":"#promptpy","title":"prompt.py","text":"<pre><code>\"\"\"Simple example for testing input streams\"\"\"\n\n\ndef prompt():\n    foo = input(\"Foo: \")\n    print(f\"foo = {foo}\")\n\n\nif __name__ == \"__main__\":\n    prompt()\n</code></pre>"},{"location":"#test_promptpy","title":"test_prompt.py","text":"<pre><code>\"\"\"Test prompt.py example\"\"\"\n\nfrom prompt import prompt\n\nfrom clirunner import CliRunner\n\n\ndef test_prompts():\n    runner = CliRunner()\n    result = runner.invoke(prompt, input=\"wau wau\\n\")\n    assert not result.exception\n    # note: unlike click.CliRunner, clirunner.CliRunner does not echo the input\n    assert \"foo = wau wau\\n\" in result.output\n</code></pre> <p>Note that the input will not be echoed to the output stream. This is different from the behavior of the <code>input()</code> function, which does echo the input and from click's <code>prompt()</code> function, which also echo's the input when under test.</p>"},{"location":"#testing-click-applications","title":"Testing Click Applications","text":"<p>Do not use <code>clirunner.CliRunner</code> to test applications built with Click, Typer, or another Click derivative. Instead, use Click's built-in CliRunner. <code>clirunner.CliRunner</code> is only for testing non-Click scripts such as those using argparse or manual sys.argv argument parsing.</p>"},{"location":"#license","title":"License","text":"<p>CliRunner is a derivative work of Click's CliRunner, and so it is licensed under the same BSD 3-clause license as Click. See the LICENSE file for details.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#clirunner","title":"CliRunner","text":"<p>The CLI runner provides functionality to invoke a Click command line script for unittesting purposes in a isolated environment.  This only works in single-threaded systems without any concurrency as it changes the global interpreter state.</p> <p>:param charset: the character set for the input and output data. :param env: a dictionary with environment variables for overriding. :param echo_stdin: if this is set to <code>True</code>, then reading from <code>&lt;stdin&gt;</code> writes                    to <code>&lt;stdout&gt;</code>.  This is useful for showing examples in                    some circumstances.  Note that regular prompts                    will automatically echo the input.</p> <p>.. versionchanged:: 8.2     <code>mix_stderr</code> parameter has been removed.</p> Source code in <code>clirunner/testing.py</code> <pre><code>class CliRunner:\n    \"\"\"The CLI runner provides functionality to invoke a Click command line\n    script for unittesting purposes in a isolated environment.  This only\n    works in single-threaded systems without any concurrency as it changes the\n    global interpreter state.\n\n    :param charset: the character set for the input and output data.\n    :param env: a dictionary with environment variables for overriding.\n    :param echo_stdin: if this is set to `True`, then reading from `&lt;stdin&gt;` writes\n                       to `&lt;stdout&gt;`.  This is useful for showing examples in\n                       some circumstances.  Note that regular prompts\n                       will automatically echo the input.\n\n    .. versionchanged:: 8.2\n        ``mix_stderr`` parameter has been removed.\n    \"\"\"\n\n    def __init__(\n        self,\n        charset: str = \"utf-8\",\n        env: cabc.Mapping[str, str | None] | None = None,\n        echo_stdin: bool = False,\n    ) -&gt; None:\n        self.charset = charset\n        self.env: cabc.Mapping[str, str | None] = env or {}\n        self.echo_stdin = echo_stdin\n\n    def get_default_prog_name(self, cli: t.Callable[..., t.Any]) -&gt; str:\n        \"\"\"Given a callable return the default program name for it.\"\"\"\n        return cli.__name__ or \"main\"\n\n    def make_env(\n        self, overrides: cabc.Mapping[str, str | None] | None = None\n    ) -&gt; cabc.Mapping[str, str | None]:\n        \"\"\"Returns the environment overrides for invoking a script.\"\"\"\n        rv = dict(self.env)\n        if overrides:\n            rv.update(overrides)\n        return rv\n\n    @contextlib.contextmanager\n    def isolation(\n        self,\n        input: str | bytes | t.IO[t.Any] | None = None,\n        env: cabc.Mapping[str, str | None] | None = None,\n        color: bool = False,\n    ) -&gt; cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]:\n        \"\"\"A context manager that sets up the isolation for invoking of a\n        command line tool.  This sets up `&lt;stdin&gt;` with the given input data\n        and `os.environ` with the overrides from the given dictionary.\n        This also rebinds some internals in Click to be mocked (like the\n        prompt functionality).\n\n        This is automatically done in the :meth:`invoke` method.\n\n        :param input: the input stream to put into `sys.stdin`.\n        :param env: the environment overrides as dictionary.\n        :param color: whether the output should contain color codes. The\n                      application can still override this explicitly.\n\n        .. versionadded:: 8.2\n            An additional output stream is returned, which is a mix of\n            `&lt;stdout&gt;` and `&lt;stderr&gt;` streams.\n\n        .. versionchanged:: 8.2\n            Always returns the `&lt;stderr&gt;` stream.\n\n        .. versionchanged:: 8.0\n            `&lt;stderr&gt;` is opened with ``errors=\"backslashreplace\"``\n            instead of the default ``\"strict\"``.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` parameter.\n        \"\"\"\n        bytes_input = make_input_stream(input, self.charset)\n        echo_input = None\n\n        old_stdin = sys.stdin\n        old_stdout = sys.stdout\n        old_stderr = sys.stderr\n\n        env = self.make_env(env)\n\n        stream_mixer = StreamMixer()\n\n        if self.echo_stdin:\n            bytes_input = echo_input = t.cast(\n                t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n            )\n\n        sys.stdin = text_input = _NamedTextIOWrapper(\n            bytes_input, encoding=self.charset, name=\"&lt;stdin&gt;\", mode=\"r\"\n        )\n\n        if self.echo_stdin:\n            # Force unbuffered reads, otherwise TextIOWrapper reads a\n            # large chunk which is echoed early.\n            text_input._CHUNK_SIZE = 1  # type: ignore\n\n        sys.stdout = _NamedTextIOWrapper(\n            stream_mixer.stdout, encoding=self.charset, name=\"&lt;stdout&gt;\", mode=\"w\"\n        )\n\n        sys.stderr = _NamedTextIOWrapper(\n            stream_mixer.stderr,\n            encoding=self.charset,\n            name=\"&lt;stderr&gt;\",\n            mode=\"w\",\n            errors=\"backslashreplace\",\n        )\n\n        default_color = color\n\n        def should_strip_ansi(\n            stream: t.IO[t.Any] | None = None, color: bool | None = None\n        ) -&gt; bool:\n            if color is None:\n                return not default_color\n            return not color\n\n        old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n        utils.should_strip_ansi = should_strip_ansi  # type: ignore\n\n        old_env = {}\n        try:\n            for key, value in env.items():\n                old_env[key] = os.environ.get(key)\n                if value is None:\n                    try:\n                        del os.environ[key]\n                    except Exception:\n                        pass\n                else:\n                    os.environ[key] = value\n            yield (stream_mixer.stdout, stream_mixer.stderr, stream_mixer.output)\n        finally:\n            for key, value in old_env.items():\n                if value is None:\n                    try:\n                        del os.environ[key]\n                    except Exception:\n                        pass\n                else:\n                    os.environ[key] = value\n            sys.stdout = old_stdout\n            sys.stderr = old_stderr\n            sys.stdin = old_stdin\n            utils.should_strip_ansi = old_should_strip_ansi  # type: ignore\n\n    def invoke(\n        self,\n        cli: t.Callable[..., t.Any],\n        args: str | cabc.Sequence[str] | None = None,\n        input: str | bytes | t.IO[t.Any] | None = None,\n        env: cabc.Mapping[str, str | None] | None = None,\n        catch_exceptions: bool = True,\n        color: bool = False,\n        **extra: t.Any,\n    ) -&gt; Result:\n        \"\"\"Invokes a command in an isolated environment.  The arguments are\n        forwarded directly to the command line script, the `extra` keyword\n        arguments are passed to the :meth:`~clickpkg.Command.main` function of\n        the command.\n\n        This returns a :class:`Result` object.\n\n        :param cli: the command to invoke\n        :param args: the arguments to invoke. It may be given as an iterable\n                     or a string. When given as string it will be interpreted\n                     as a Unix shell command. More details at\n                     :func:`shlex.split`.\n        :param input: the input data for `sys.stdin`.\n        :param env: the environment overrides.\n        :param catch_exceptions: Whether to catch any other exceptions than\n                                 ``SystemExit``.\n        :param extra: the keyword arguments to pass to :meth:`main`.\n        :param color: whether the output should contain color codes. The\n                      application can still override this explicitly.\n\n        .. versionadded:: 8.2\n            The result object has the ``output_bytes`` attribute with\n            the mix of ``stdout_bytes`` and ``stderr_bytes``, as the user would\n            see it in its terminal.\n\n        .. versionchanged:: 8.2\n            The result object always returns the ``stderr_bytes`` stream.\n\n        .. versionchanged:: 8.0\n            The result object has the ``return_value`` attribute with\n            the value returned from the invoked command.\n\n        .. versionchanged:: 4.0\n            Added the ``color`` parameter.\n\n        .. versionchanged:: 3.0\n            Added the ``catch_exceptions`` parameter.\n\n        .. versionchanged:: 3.0\n            The result object has the ``exc_info`` attribute with the\n            traceback if available.\n        \"\"\"\n        exc_info = None\n        with self.isolation(input=input, env=env, color=color) as outstreams:\n            return_value = None\n            exception: BaseException | None = None\n            exit_code = 0\n\n            if isinstance(args, str):\n                args = shlex.split(args)\n\n            try:\n                prog_name = extra.pop(\"prog_name\")\n            except KeyError:\n                prog_name = self.get_default_prog_name(cli)\n\n            # set up sys.argv properly with the arguments\n            call_args = args or []\n            old_argv = sys.argv\n            sys.argv = [prog_name, *call_args]\n            try:\n                return_value = cli()\n            except SystemExit as e:\n                exc_info = sys.exc_info()\n                e_code = t.cast(\"int | t.Any | None\", e.code)\n\n                if e_code is None:\n                    e_code = 0\n\n                if e_code != 0:\n                    exception = e\n\n                if not isinstance(e_code, int):\n                    sys.stdout.write(str(e_code))\n                    sys.stdout.write(\"\\n\")\n                    e_code = 1\n\n                exit_code = e_code\n\n            except Exception as e:\n                if not catch_exceptions:\n                    raise\n                exception = e\n                exit_code = 1\n                exc_info = sys.exc_info()\n            finally:\n                sys.argv = old_argv\n                sys.stdout.flush()\n                sys.stderr.flush()\n                stdout = outstreams[0].getvalue()\n                stderr = outstreams[1].getvalue()\n                output = outstreams[2].getvalue()\n\n        return Result(\n            runner=self,\n            stdout_bytes=stdout,\n            stderr_bytes=stderr,\n            output_bytes=output,\n            return_value=return_value,\n            exit_code=exit_code,\n            exception=exception,\n            exc_info=exc_info,  # type: ignore\n        )\n\n    @contextlib.contextmanager\n    def isolated_filesystem(\n        self, temp_dir: str | os.PathLike[str] | None = None\n    ) -&gt; cabc.Iterator[str]:\n        \"\"\"A context manager that creates a temporary directory and\n        changes the current working directory to it. This isolates tests\n        that affect the contents of the CWD to prevent them from\n        interfering with each other.\n\n        :param temp_dir: Create the temporary directory under this\n            directory. If given, the created directory is not removed\n            when exiting.\n\n        .. versionchanged:: 8.0\n            Added the ``temp_dir`` parameter.\n        \"\"\"\n        cwd = os.getcwd()\n        dt = tempfile.mkdtemp(dir=temp_dir)\n        os.chdir(dt)\n\n        try:\n            yield dt\n        finally:\n            os.chdir(cwd)\n\n            if temp_dir is None:\n                try:\n                    shutil.rmtree(dt)\n                except OSError:  # noqa: B014\n                    pass\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.get_default_prog_name","title":"<code>get_default_prog_name(cli)</code>","text":"<p>Given a callable return the default program name for it.</p> Source code in <code>clirunner/testing.py</code> <pre><code>def get_default_prog_name(self, cli: t.Callable[..., t.Any]) -&gt; str:\n    \"\"\"Given a callable return the default program name for it.\"\"\"\n    return cli.__name__ or \"main\"\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.invoke","title":"<code>invoke(cli, args=None, input=None, env=None, catch_exceptions=True, color=False, **extra)</code>","text":"<p>Invokes a command in an isolated environment.  The arguments are forwarded directly to the command line script, the <code>extra</code> keyword arguments are passed to the :meth:<code>~clickpkg.Command.main</code> function of the command.</p> <p>This returns a :class:<code>Result</code> object.</p> <p>:param cli: the command to invoke :param args: the arguments to invoke. It may be given as an iterable              or a string. When given as string it will be interpreted              as a Unix shell command. More details at              :func:<code>shlex.split</code>. :param input: the input data for <code>sys.stdin</code>. :param env: the environment overrides. :param catch_exceptions: Whether to catch any other exceptions than                          <code>SystemExit</code>. :param extra: the keyword arguments to pass to :meth:<code>main</code>. :param color: whether the output should contain color codes. The               application can still override this explicitly.</p> <p>.. versionadded:: 8.2     The result object has the <code>output_bytes</code> attribute with     the mix of <code>stdout_bytes</code> and <code>stderr_bytes</code>, as the user would     see it in its terminal.</p> <p>.. versionchanged:: 8.2     The result object always returns the <code>stderr_bytes</code> stream.</p> <p>.. versionchanged:: 8.0     The result object has the <code>return_value</code> attribute with     the value returned from the invoked command.</p> <p>.. versionchanged:: 4.0     Added the <code>color</code> parameter.</p> <p>.. versionchanged:: 3.0     Added the <code>catch_exceptions</code> parameter.</p> <p>.. versionchanged:: 3.0     The result object has the <code>exc_info</code> attribute with the     traceback if available.</p> Source code in <code>clirunner/testing.py</code> <pre><code>def invoke(\n    self,\n    cli: t.Callable[..., t.Any],\n    args: str | cabc.Sequence[str] | None = None,\n    input: str | bytes | t.IO[t.Any] | None = None,\n    env: cabc.Mapping[str, str | None] | None = None,\n    catch_exceptions: bool = True,\n    color: bool = False,\n    **extra: t.Any,\n) -&gt; Result:\n    \"\"\"Invokes a command in an isolated environment.  The arguments are\n    forwarded directly to the command line script, the `extra` keyword\n    arguments are passed to the :meth:`~clickpkg.Command.main` function of\n    the command.\n\n    This returns a :class:`Result` object.\n\n    :param cli: the command to invoke\n    :param args: the arguments to invoke. It may be given as an iterable\n                 or a string. When given as string it will be interpreted\n                 as a Unix shell command. More details at\n                 :func:`shlex.split`.\n    :param input: the input data for `sys.stdin`.\n    :param env: the environment overrides.\n    :param catch_exceptions: Whether to catch any other exceptions than\n                             ``SystemExit``.\n    :param extra: the keyword arguments to pass to :meth:`main`.\n    :param color: whether the output should contain color codes. The\n                  application can still override this explicitly.\n\n    .. versionadded:: 8.2\n        The result object has the ``output_bytes`` attribute with\n        the mix of ``stdout_bytes`` and ``stderr_bytes``, as the user would\n        see it in its terminal.\n\n    .. versionchanged:: 8.2\n        The result object always returns the ``stderr_bytes`` stream.\n\n    .. versionchanged:: 8.0\n        The result object has the ``return_value`` attribute with\n        the value returned from the invoked command.\n\n    .. versionchanged:: 4.0\n        Added the ``color`` parameter.\n\n    .. versionchanged:: 3.0\n        Added the ``catch_exceptions`` parameter.\n\n    .. versionchanged:: 3.0\n        The result object has the ``exc_info`` attribute with the\n        traceback if available.\n    \"\"\"\n    exc_info = None\n    with self.isolation(input=input, env=env, color=color) as outstreams:\n        return_value = None\n        exception: BaseException | None = None\n        exit_code = 0\n\n        if isinstance(args, str):\n            args = shlex.split(args)\n\n        try:\n            prog_name = extra.pop(\"prog_name\")\n        except KeyError:\n            prog_name = self.get_default_prog_name(cli)\n\n        # set up sys.argv properly with the arguments\n        call_args = args or []\n        old_argv = sys.argv\n        sys.argv = [prog_name, *call_args]\n        try:\n            return_value = cli()\n        except SystemExit as e:\n            exc_info = sys.exc_info()\n            e_code = t.cast(\"int | t.Any | None\", e.code)\n\n            if e_code is None:\n                e_code = 0\n\n            if e_code != 0:\n                exception = e\n\n            if not isinstance(e_code, int):\n                sys.stdout.write(str(e_code))\n                sys.stdout.write(\"\\n\")\n                e_code = 1\n\n            exit_code = e_code\n\n        except Exception as e:\n            if not catch_exceptions:\n                raise\n            exception = e\n            exit_code = 1\n            exc_info = sys.exc_info()\n        finally:\n            sys.argv = old_argv\n            sys.stdout.flush()\n            sys.stderr.flush()\n            stdout = outstreams[0].getvalue()\n            stderr = outstreams[1].getvalue()\n            output = outstreams[2].getvalue()\n\n    return Result(\n        runner=self,\n        stdout_bytes=stdout,\n        stderr_bytes=stderr,\n        output_bytes=output,\n        return_value=return_value,\n        exit_code=exit_code,\n        exception=exception,\n        exc_info=exc_info,  # type: ignore\n    )\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.isolated_filesystem","title":"<code>isolated_filesystem(temp_dir=None)</code>","text":"<p>A context manager that creates a temporary directory and changes the current working directory to it. This isolates tests that affect the contents of the CWD to prevent them from interfering with each other.</p> <p>:param temp_dir: Create the temporary directory under this     directory. If given, the created directory is not removed     when exiting.</p> <p>.. versionchanged:: 8.0     Added the <code>temp_dir</code> parameter.</p> Source code in <code>clirunner/testing.py</code> <pre><code>@contextlib.contextmanager\ndef isolated_filesystem(\n    self, temp_dir: str | os.PathLike[str] | None = None\n) -&gt; cabc.Iterator[str]:\n    \"\"\"A context manager that creates a temporary directory and\n    changes the current working directory to it. This isolates tests\n    that affect the contents of the CWD to prevent them from\n    interfering with each other.\n\n    :param temp_dir: Create the temporary directory under this\n        directory. If given, the created directory is not removed\n        when exiting.\n\n    .. versionchanged:: 8.0\n        Added the ``temp_dir`` parameter.\n    \"\"\"\n    cwd = os.getcwd()\n    dt = tempfile.mkdtemp(dir=temp_dir)\n    os.chdir(dt)\n\n    try:\n        yield dt\n    finally:\n        os.chdir(cwd)\n\n        if temp_dir is None:\n            try:\n                shutil.rmtree(dt)\n            except OSError:  # noqa: B014\n                pass\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.isolation","title":"<code>isolation(input=None, env=None, color=False)</code>","text":"<p>A context manager that sets up the isolation for invoking of a command line tool.  This sets up <code>&lt;stdin&gt;</code> with the given input data and <code>os.environ</code> with the overrides from the given dictionary. This also rebinds some internals in Click to be mocked (like the prompt functionality).</p> <p>This is automatically done in the :meth:<code>invoke</code> method.</p> <p>:param input: the input stream to put into <code>sys.stdin</code>. :param env: the environment overrides as dictionary. :param color: whether the output should contain color codes. The               application can still override this explicitly.</p> <p>.. versionadded:: 8.2     An additional output stream is returned, which is a mix of     <code>&lt;stdout&gt;</code> and <code>&lt;stderr&gt;</code> streams.</p> <p>.. versionchanged:: 8.2     Always returns the <code>&lt;stderr&gt;</code> stream.</p> <p>.. versionchanged:: 8.0     <code>&lt;stderr&gt;</code> is opened with <code>errors=\"backslashreplace\"</code>     instead of the default <code>\"strict\"</code>.</p> <p>.. versionchanged:: 4.0     Added the <code>color</code> parameter.</p> Source code in <code>clirunner/testing.py</code> <pre><code>@contextlib.contextmanager\ndef isolation(\n    self,\n    input: str | bytes | t.IO[t.Any] | None = None,\n    env: cabc.Mapping[str, str | None] | None = None,\n    color: bool = False,\n) -&gt; cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]:\n    \"\"\"A context manager that sets up the isolation for invoking of a\n    command line tool.  This sets up `&lt;stdin&gt;` with the given input data\n    and `os.environ` with the overrides from the given dictionary.\n    This also rebinds some internals in Click to be mocked (like the\n    prompt functionality).\n\n    This is automatically done in the :meth:`invoke` method.\n\n    :param input: the input stream to put into `sys.stdin`.\n    :param env: the environment overrides as dictionary.\n    :param color: whether the output should contain color codes. The\n                  application can still override this explicitly.\n\n    .. versionadded:: 8.2\n        An additional output stream is returned, which is a mix of\n        `&lt;stdout&gt;` and `&lt;stderr&gt;` streams.\n\n    .. versionchanged:: 8.2\n        Always returns the `&lt;stderr&gt;` stream.\n\n    .. versionchanged:: 8.0\n        `&lt;stderr&gt;` is opened with ``errors=\"backslashreplace\"``\n        instead of the default ``\"strict\"``.\n\n    .. versionchanged:: 4.0\n        Added the ``color`` parameter.\n    \"\"\"\n    bytes_input = make_input_stream(input, self.charset)\n    echo_input = None\n\n    old_stdin = sys.stdin\n    old_stdout = sys.stdout\n    old_stderr = sys.stderr\n\n    env = self.make_env(env)\n\n    stream_mixer = StreamMixer()\n\n    if self.echo_stdin:\n        bytes_input = echo_input = t.cast(\n            t.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)\n        )\n\n    sys.stdin = text_input = _NamedTextIOWrapper(\n        bytes_input, encoding=self.charset, name=\"&lt;stdin&gt;\", mode=\"r\"\n    )\n\n    if self.echo_stdin:\n        # Force unbuffered reads, otherwise TextIOWrapper reads a\n        # large chunk which is echoed early.\n        text_input._CHUNK_SIZE = 1  # type: ignore\n\n    sys.stdout = _NamedTextIOWrapper(\n        stream_mixer.stdout, encoding=self.charset, name=\"&lt;stdout&gt;\", mode=\"w\"\n    )\n\n    sys.stderr = _NamedTextIOWrapper(\n        stream_mixer.stderr,\n        encoding=self.charset,\n        name=\"&lt;stderr&gt;\",\n        mode=\"w\",\n        errors=\"backslashreplace\",\n    )\n\n    default_color = color\n\n    def should_strip_ansi(\n        stream: t.IO[t.Any] | None = None, color: bool | None = None\n    ) -&gt; bool:\n        if color is None:\n            return not default_color\n        return not color\n\n    old_should_strip_ansi = utils.should_strip_ansi  # type: ignore\n    utils.should_strip_ansi = should_strip_ansi  # type: ignore\n\n    old_env = {}\n    try:\n        for key, value in env.items():\n            old_env[key] = os.environ.get(key)\n            if value is None:\n                try:\n                    del os.environ[key]\n                except Exception:\n                    pass\n            else:\n                os.environ[key] = value\n        yield (stream_mixer.stdout, stream_mixer.stderr, stream_mixer.output)\n    finally:\n        for key, value in old_env.items():\n            if value is None:\n                try:\n                    del os.environ[key]\n                except Exception:\n                    pass\n            else:\n                os.environ[key] = value\n        sys.stdout = old_stdout\n        sys.stderr = old_stderr\n        sys.stdin = old_stdin\n        utils.should_strip_ansi = old_should_strip_ansi  # type: ignore\n</code></pre>"},{"location":"reference/#clirunner.CliRunner.make_env","title":"<code>make_env(overrides=None)</code>","text":"<p>Returns the environment overrides for invoking a script.</p> Source code in <code>clirunner/testing.py</code> <pre><code>def make_env(\n    self, overrides: cabc.Mapping[str, str | None] | None = None\n) -&gt; cabc.Mapping[str, str | None]:\n    \"\"\"Returns the environment overrides for invoking a script.\"\"\"\n    rv = dict(self.env)\n    if overrides:\n        rv.update(overrides)\n    return rv\n</code></pre>"}]}